
! Remap runoff between two grids. A weight file generated by
! ESMF_RegridWeightGen is used to remap between two grids. Then kdrunoff_mod is
! used to move any water "landing" onto the nearest ocean point. Note that
! remap_runoff_new() should only be called once as it is expensive. Example use:
!
!  type(remap_runoff_class) :: remap_runoff
!  call remap_runoff_new(remap_runoff, 'rmp_jrar_to_cict_CONSERV.nc', &
!                        dest_lats, dest_lons, dest_mask)
!  call remap_runoff_do(remap_runoff, runof, remapped_runoff, dest_mask)
!  call remap_runoff_del(remap_runoff)

module remap_runoff_mod

  use netcdf
  use kdrunoff_mod, only : kdrunoff_class, kdrunoff_new, kdrunoff_del
  use kdrunoff_mod, only : kdrunoff_remap
  use, intrinsic :: iso_fortran_env, only : stderr=>error_unit

  implicit none
  private

  type :: remap_runoff_class
    real, dimension(:), allocatable :: row, col, s
    real, dimension(:), allocatable :: frac_a, frac_b, area_a, area_b
    integer :: n_s, n_a, n_b
    integer :: num_land_pts, num_ocean_pts
    type(kdrunoff_class) :: kdrunoff
  end type remap_runoff_class

  ! FIXME: would like to make this smaller
  real, parameter :: MAX_RELATIVE_ERROR = 1e-09

  public :: remap_runoff_class, remap_runoff_new, remap_runoff_del
  public :: remap_runoff_do

contains

  subroutine remap_runoff_new(this, weights, lats, lons, mask, &
      num_runoff_caps, runoff_caps, &
      runoff_caps_is, runoff_caps_ie, &
      runoff_caps_js, runoff_caps_je)
    type(remap_runoff_class), intent(inout) :: this

    character(len=*), intent(in) :: weights
    real, dimension(:, :), intent(in) :: lats, lons, mask
    integer, intent(in) :: num_runoff_caps
    real, dimension(:), intent(in) :: runoff_caps
    integer, dimension(:), intent(in) :: runoff_caps_is
    integer, dimension(:), intent(in) :: runoff_caps_ie
    integer, dimension(:), intent(in) :: runoff_caps_js
    integer, dimension(:), intent(in) :: runoff_caps_je

    integer :: ncid
    integer :: n_s, n_a, n_b

    ! Initialise remapping weights arrays
    call ncheck(nf90_open(trim(weights), NF90_NOWRITE, ncid), &
                "remap_runoff_new: can't open weights file: "//trim(weights))
    call read_weight_dims(ncid, n_s, n_a, n_b)

    allocate(this%row(n_s), this%col(n_s), this%s(n_s))
    allocate(this%frac_a(n_a), this%frac_b(n_b))
    allocate(this%area_a(n_a), this%area_b(n_b))

    call read_weights(ncid, this%row, this%col, this%s, &
                      this%frac_a, this%frac_b, this%area_a, this%area_b)

    this%n_s = n_s
    this%n_a = n_a
    this%n_b = n_b

    call kdrunoff_new(this%kdrunoff, mask, lons, lats, &
                      this%num_land_pts, this%num_ocean_pts, &
                      num_runoff_caps, runoff_caps, &
                      runoff_caps_is, runoff_caps_ie, &
                      runoff_caps_js, runoff_caps_je)

  end subroutine remap_runoff_new

  subroutine remap_runoff_del(this)
    type(remap_runoff_class), intent(inout) :: this

    deallocate(this%row, this%col, this%s)
    deallocate(this%frac_a, this%frac_b)
    deallocate(this%area_a, this%area_b)

    call kdrunoff_del(this%kdrunoff)

  end subroutine remap_runoff_del

  subroutine remap_runoff_do(this, runoff_in, runoff_out, mask, debug)
    type(remap_runoff_class), intent(inout) :: this

    real, dimension(:, :), intent(in) :: runoff_in
    real, dimension(:, :), intent(inout) :: runoff_out
    real, dimension(:, :), intent(in) :: mask
    logical, optional, intent(in) :: debug

    real, dimension(size(runoff_out)) :: dst_field
    real, dimension(size(runoff_in)) :: src_field
    real, dimension(size(runoff_out, 1), size(runoff_out, 2)) :: areas
    real :: total_runoff_into_kd, total_runoff_outof_kd
    real :: rel_err, start_time, end_time
    integer :: i, j
    logical :: dbg

    dbg = .false.
    if (present(debug)) then
      dbg = debug
    endif

    if (dbg) then
      call cpu_time(start_time)
    endif

    ! Do interpolation.
    src_field = reshape(runoff_in, (/ size(runoff_in) /))

    runoff_out(:, :) = 0.0
    dst_field(:) = 0.0

    ! Conservation checks are done within apply_weights
    call apply_weights(this, src_field, dst_field)

    runoff_out(:, :) = reshape(dst_field, shape(runoff_out)) 
    areas(:, :) = reshape(this%area_b, shape(runoff_out))

    ! Now move runoff from land to ocean.
    total_runoff_into_kd = sum(runoff_out(:, :) * areas(:, :))
    if (total_runoff_into_kd > 0.0 .and. this%num_ocean_pts == 0) then
      write(*,*) "Error: remap_runoff_do() can't remap runoff"
      stop
    endif

    call kdrunoff_remap(this%kdrunoff, runoff_out, &
                        reshape(this%area_b, shape(runoff_out)))

    total_runoff_outof_kd = sum(runoff_out(:, :) * areas(:, :))

    ! Check that runoff is conserving
    rel_err = abs(total_runoff_into_kd - total_runoff_outof_kd) /  &
                total_runoff_outof_kd
    if (rel_err > MAX_RELATIVE_ERROR) then
      write(*,*) "Error: remap_runoff_do() runoff not conserving"
      stop
    endif

    ! Check that there is no runoff on land.
    do j=1, size(mask, 2)
      do i=1, size(mask, 1)
        if (mask(i, j) < 0.5 .and. runoff_out(i, j) > 0.0) then
          write(*, *) "Error: remap_runoff_do() runoff on land"
        endif
      enddo
    enddo

    ! Output the remapped field to a netcdf file.
    if (dbg) then
      call cpu_time(end_time)
      write(*,*) 'remap_runoff_do runtime (s): ', (end_time - start_time)
      write(*,*) 'remap_runoff_do rel_err: ', rel_err
      call write_to_netcdf(runoff_out, 'remap_runoff_debug.nc')
    endif

  end subroutine remap_runoff_do

  subroutine read_weights(ncid, row, col, s, frac_a, frac_b, area_a, area_b)
    integer, intent(in) :: ncid
    real, dimension(:), intent(inout) :: row, col, s
    real, dimension(:), intent(inout) :: frac_a, frac_b, area_a, area_b

    integer :: rowid, colid, sid
    integer :: frac_aid, frac_bid, area_aid, area_bid
    integer :: status

    status = nf90_inq_varid(ncid, "dst_address", rowid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "row", rowid), "Can't find row")
    endif
    call ncheck(nf90_get_var(ncid, rowid, row), "Can't read row")

    status = nf90_inq_varid(ncid, "src_address", colid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "col", colid), "Can't find col")
    endif
    call ncheck(nf90_get_var(ncid, colid, col), "Can't read col")

    call ncheck(nf90_inq_varid(ncid, "S", sid), "Can't find S")
    call ncheck(nf90_get_var(ncid, sid, s), "Can't read S")

    ! A (src) side area and frac
    status = nf90_inq_varid(ncid, "src_grid_area", area_aid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "area_a", area_aid), &
                  "Can't find area_a")
    endif
    call ncheck(nf90_get_var(ncid, area_aid, area_a), "Can't read area_a")

    status = nf90_inq_varid(ncid, "src_grid_frac", frac_aid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "frac_a", frac_aid), &
                  "Can't find frac_a")
    endif
    call ncheck(nf90_get_var(ncid, frac_aid, frac_a), "Can't read frac_a")

    ! B (dest) side area and frac
    status = nf90_inq_varid(ncid, "dst_grid_area", area_bid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "area_b", area_bid), &
                  "Can't find frac_b")
    endif
    call ncheck(nf90_get_var(ncid, area_bid, area_b), &
                "Can't read area_b")

    status = nf90_inq_varid(ncid, "dst_grid_frac", frac_bid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "frac_b", frac_bid), &
                  "Can't find frac_b")
    endif
    call ncheck(nf90_get_var(ncid, frac_bid, frac_b), "Can't read frac_b")

  end subroutine read_weights

  subroutine read_weight_dims(ncid, n_s, n_a, n_b)
    integer, intent(in) :: ncid
    integer, intent(out) :: n_s, n_a, n_b

    integer :: n_sid, n_aid, n_bid
    integer :: status

    ! Read out, these names can use either the SCRIP or ESMF convention.
    status = nf90_inq_dimid(ncid, "num_links", n_sid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "n_s", n_sid), &
                  "Can't find n_s")
    endif
    call ncheck(nf90_inquire_dimension(ncid, n_sid, len=n_s), &
                "Can't read n_s")

    status = nf90_inq_dimid(ncid, "src_grid_size", n_aid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "n_a", n_aid), &
                  "Can't find n_a")
    endif
    call ncheck(nf90_inquire_dimension(ncid, n_aid, len=n_a), &
                "Can't read n_a")

    status = nf90_inq_dimid(ncid, "dst_grid_size", n_bid)
    if (status /= nf90_noerr) then
      call ncheck(nf90_inq_varid(ncid, "n_b", n_bid), &
                  "Can't find n_b")
    endif
    call ncheck(nf90_inquire_dimension(ncid, n_bid, len=n_b), &
                "Can't read n_b")

  end subroutine read_weight_dims

  ! See http://www.earthsystemmodeling.org/esmf_releases/public/last/ESMF_refdoc/node3.html
  ! for explanation of the code below.
  subroutine apply_weights(this, src_field, dst_field)
    type(remap_runoff_class), intent(in) :: this
    real, dimension(:), intent(in) :: src_field
    real, dimension(:), intent(inout) :: dst_field

    real :: src_total, dst_total, rel_err
    integer :: i

    ! Apply weights
    do i=1, this%n_s
       dst_field(int(this%row(i))) = dst_field(int(this%row(i))) + &
                                  this%S(i)*src_field(int(this%col(i)))
    enddo

    ! Adjust destination field by fraction. Not strictly needed for global
    ! remapping but doesn't hurt.
    do i=1, this%n_b
      if (this%frac_b(i) /= 0.0) then
        dst_field(i) = dst_field(i)/this%frac_b(i)
      endif
    enddo

    ! Calculate source integral
    src_total = 0.0
    do i=1, size(src_field)
      src_total = src_total + src_field(i)*this%area_a(i)*this%frac_a(i)
    enddo

    ! Calculate destination integral
    dst_total= 0.0
    do i=1, size(dst_field)
      dst_total = dst_total + dst_field(i)*this%area_b(i)
    enddo

    ! Compare the above.
    rel_err = abs(src_total - dst_total) / src_total
    if (rel_err > MAX_RELATIVE_ERROR) then
      write(stderr, *) &
        "rel_err > MAX_RELATIVE_ERROR (", rel_err, ">", MAX_RELATIVE_ERROR, ")"
      stop 'Error: apply_weights not conserving.'
    endif

  end subroutine apply_weights

  subroutine create_netcdf(file_name, nx, ny)
    character(len=*), intent(in) :: file_name
    integer, intent(in) :: nx, ny

    integer :: ncid, xdim_id, ydim_id, tdim_id
    integer, dimension(3) :: arrdims
    integer :: array_id

    integer :: ierr

    ! create the file
    call ncheck(nf90_create(path=trim(file_name), cmode=NF90_CLOBBER, ncid=ncid), &
                trim(file_name)//' create')

    ! define the dimensions
    call ncheck(nf90_def_dim(ncid, 'X', nx, xdim_id), &
                trim(file_name)//' def_dim x')
    call ncheck(nf90_def_dim(ncid, 'Y', ny, ydim_id), &
                trim(file_name)//' def_dim y')
    call ncheck(nf90_def_dim(ncid, 'time', NF90_UNLIMITED, tdim_id), &
                trim(file_name)//' def_dim t')

    ! define variabls on dimensions
    arrdims = (/ xdim_id, ydim_id, tdim_id /)
    call ncheck(nf90_def_var(ncid, 'runoff',  NF90_DOUBLE, arrdims, array_id), &
                trim(file_name)//' def_var')

    ! and assign units
    call ncheck(nf90_put_att(ncid, array_id, 'units', 'kg/m^2/s'), &
                trim(file_name)//' put_att')

    ! done defining
    call ncheck(nf90_enddef(ncid), trim(file_name)//' enddef')

  end subroutine create_netcdf

  subroutine write_to_netcdf(array, file_name)
    real, intent(in), dimension(:,:) :: array
    character(len=*), intent(in) :: file_name

    integer :: ierr, nx, ny, t
    integer :: ncid, time_id, array_id
    logical :: file_exists

    nx = size(array, 1)
    ny = size(array, 2)

    ! See whether file exists, if not create.
    inquire(file=trim(file_name), exist=file_exists)
    if (file_exists) then
      call ncheck(nf90_open(trim(file_name), NF90_WRITE, ncid), &
                  trim(file_name)//' open')
      ! Get the next time dimension
      call ncheck(nf90_inq_dimid(ncid, "time", time_id), &
                  trim(file_name)//' inq_dimid')
      call ncheck(nf90_inquire_dimension(ncid, time_id, len=t), &
                  trim(file_name)//' inquire_dimension')
      t = t+1
    else
      call create_netcdf(file_name, nx, ny)
      call ncheck(nf90_open(trim(file_name), NF90_WRITE, ncid), &
                  trim(file_name)//' open')
      t = 1
    endif

    call ncheck(nf90_inq_varid(ncid, "runoff", array_id), & 
                       trim(file_name)//' inq_varid')

    ! Write out the values
    call ncheck(nf90_put_var(ncid, array_id, array, start=(/1, 1, t/), &
                             count=(/nx, ny, 1/)), &
                trim(file_name)//' put_var')

    ! close; done
    call ncheck(nf90_close(ncid), trim(file_name)//' close')
  end subroutine write_to_netcdf

  subroutine ncheck(status, error_str)
    integer, intent(in) :: status
    character(len=*), intent(in) :: error_str

    if (status /= nf90_noerr) then
      write(stderr,'(/a)') 'Error: '
      write(stderr,'(a)') error_str
      write(stderr,'(a/)') trim(nf90_strerror(status))
      stop 'Error: remap_runoff_mod, ncheck failed.'
    endif
  end subroutine ncheck

end module remap_runoff_mod
